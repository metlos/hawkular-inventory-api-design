FORMAT: 1A

# Hawkular Inventory API
This is a draft of the REST API of inventory in Hawkular.

**(You can click on the individual URIs to see examples of the data
exchange)**

Nomenclature:

* _Feed_ - source of data that sends data to the REST API defined here. The
feed is assumed to have a number of implicit capabilities:
  * _identity_ - the feed is able to remember its identity throughout the
  restarts.
* _Capabilities_ - the feeds can support different additional functionality.
Currently, the additional capabilities are the following (list is incomplete
and evolving):
  * _metadata_ - the feed is able to define the metadata about the data it
  sends
  * _monitoring_ - the feed sends monitoring data
  * _configuration_ - the feed is able to send and receive configuration
  * _execution_ - the feed is able to execute operations on request
  * _scheduling_ - the feed is able to schedule its actions (montoring data
  gathering, applying configuration, operation execution, ...)
  * _discovery_ - the feed can scan for new stuff to report on. This is
  somewhat implicit, but feeds declaring this capability can do so on
  demand.
  
It is assumed that the connections between the feeds and the REST endpoint
is always initiated by the feeds. If the feed wants to support receiving of
commands, it needs to keep the connection open. It is yet to be defined what
kind of connection the feeds will have to use (HTTP, WebSockets?).

Authentification is not dealt with in this draft but it is assumed it would
be handled externally/transparently to the API through Keycloak or other SSO
provider. Authorization is also not dealt with.

# Group Feed

All things about feeds themselves - CRUD + registration.

## Feed [/feeds/{id}]


+ Model (application/json)

        {
            "id" : "1234-abcd",
            "capabilities" : ["identity", "resources", "discovery", 
                              "monitor", "operations", "configuration"]
        }

+ Parameters

    + id (required, string) ... the assigned ID of the feed.

### Get a single feed [GET]

+ Response 200

    [Feed][]

### Delete the feed from RHQ along with everything it defines [DELETE]
+ Response 204

## Feeds [/feeds]
Feed registration, etc.

### Registration [POST]
This is where the feeds register themselves.

+ Request (application/json)

        {
            "id" : "suggested-unique-id", //this might or might not be 
                                          //accepted by the rhq server
            "capabilities" : ["identity", "resources", "discovery", 
                              "monitor", "operations", "configuration"]    
        }

+ Response 201

    [Feed][]

### Feed Collection [GET]
Returns all feeds that rhq knows of.

+ Response 200 (application/json)

        [
            { 
                "id" : "1234-abcd",
                "capabilities" : ["identity", "resources", "discovery", 
                                  "monitor", "operations", "configuration"]
            }
        ]


## Discovery [/discovery]
Receiving discovery reports. Note that this step is completely voluntary
in the feed workflow and will be only performed by feeds capable of 
discovery.

### Send discovery report [POST]
Sends the discovery report up to the server. The example request contains
an example resource object for some of the possible feed types (rhq agent, 
collectd proxy, kubernetes proxy).

The `dataDefs` list the ids (and optionally types) of the data that 
the resources are supposed to contain.

+ Request (application/json)

        [
            { //RHQ agent
                "address" : "rhq://1234-abcd/PLATFORM/cpu1",
                "name" : "CPU1",
                "description" : "kachny",
                "version" : null,
                "dataDefs" : [
                    {
                        "id" : "rhq://1234-abcd/PLATFORM/cpu1/systemLoad",
                        "type" : "rhq-type://platforms/CPU/systemLoad"
                    }, 
                    {
                        "id" : "rhq://1234-abcd/PLATFORM/cpu1/userLoad",
                        "type" : "rhq-type://platforms/CPU/userLoad"
                    }
                ]
            },
            { //Collectd Proxy - Collectd can either use the "true" hostname 
              //as its host part of the identifier or it can be configured 
              //to use a specific value for host.
              //We can just use this value, because it is supposed to be 
              //unique in the environment.
              //Notice how collectd datum identifier is used to extract the
              //agentID, resourceAddress and also resource name.
              //
              //The identifier has this form ([] denotes optional parts):
              //host/plugin[-pluginInstance]/type[-typeInstance]
              //we use this mapping:
              //host = agentID
              //plugin[-pluginInstance] = resourceAddress and name 
              //(collectd "resources" are not hierarchical). 
              //
              //the type[-typeInstance] is not used for resource 
              //identification because it is meant to identify the measured
              //thing inside something that is designated by the 
              //plugin[-pluginInstance] identifier.
              //
              //The type identifier is composed as follows:
              //collectd-type://plugin/type-typeInstance
              
                "address" : "collectd://hostX/cpu-0",
                "name" : "cpu-0",
                "description" : null,
                "version" : null,
                "dataDefs" : [
                    {
                        "id" : "collectd://hostX/cpu-0/cpu-user",
                        "type" : "collectd-type://cpu/cpu-user"
                    },
                    {
                        "id" : "collectd://hostX/cpu-0/cpu-idle",
                        "type" : "collectd-type://cpu/cpu-idle"
                    }
                ]
            },
            { //Kubernetes Proxy
                "address" : "kubernetes://1234-abcd/pod/pod1",
                "name" : "pod1",
                "dataDefs" : [
                    {
                        "id" : "cadvisor://1234-abcd/pod/pod1/metric",
                        "type" : "cadvisor-type://..."
                    }
                ]
            },
            { //Feed that doesn't understand resources, but somehow knows 
              //the data types of the stuff it sends up. If it didn't know 
              //even that - it can merely start pushing data and RHQ will 
              //analyze it, represent it somehow in discovery queue (and 
              //drop it, because the resource would not be in the 
              //inventory).
                "dataDefs" : [
                    {
                        "id" : "in-app-metric1",
                        "type" : "custom-type:acme-property"
                    },
                ]
            }
        ]
        
+ Response 201

## Resource [/resources{?id,address,at}]
Work with resources.

+ Model (application/json)

        {
            "id" : "9876-zyxw",
            "name" : "cpu0",
            "description" : null,
            "version" : null,
            "address" : "rhq://1234-abcd/PLATFORM/cpu0"
            "metrics" : [
                {
                    "id" : "collectd://hostX/cpu-0/cpu-load",
                    "type" : "collectd-type://cpu/cpu-load"
                }
            ],
            "connection" : {
                "username" : "kachnak",
                "password" : "clear-text-ftw"
            },
            "connectionType" : "custom-type://username-and-password",
            "configuration" : {
                "frequency" : "100"
            },
            "configurationType" : 
                "rhq-type://platforms/CPU/resourceConfiguration",
            "operations" : [
                {
                    "id" : "rhq://1234-abcd/PLATFORM/cpu0/overclock",
                    "type" : "rhq-type://platforms/CPU/overclock"
                }
            ]
        }

+ Parameters
    + id (optional, uuid, `123`) ... 
        Resources are server side concept, so they have a server-side ID.
        Either id or address is required to get a resource.
    + address (optional, string, `rhq://agentX/PLATFORM/cpu1`) ...
        The address of the resource in the agent-specific format.
        Either id or address is required to get a resource.
    + at (optional, long) ... work with the resource as defined at the time 
        specified as a epoch timestamp.

### Get a single resource [GET]

+ Response 200

    [Resource][]
 
### Delete a single resource [DELETE]
Note that the resource is not deleted, it is merely flagged as such (in a 
versioned manner). Also note that the `at` parameter isn't considered. Only 
the "current" version of the resource can be deleted.

+ Response 204

### Create a new resource [POST]
This is going to create a new "synthetic" resource. This resource was not 
suggested by any agent (agents do that via the `/discovery` endpoint). It 
is created by the user of the API.

Because the individual datapoints coming from the agent are addressable, we 
can compose it from them.

If either `id` or `address` parameter is specified, this is going to update 
the definition of the resource (in a versioned manner). Otherwise a new 
resource will be created.

The `at` parameter isn't taken into account.

+ Request (application/json)

        {
            "name" : "custom-cpu",
            "description" : "my own CPU resource",
            "metrics" : [
                {
                    "id" : "collectd://hostX/cpu-0/cpu-load",
                    "type" : "collectd-type://cpu/cpu-load"
                }
            ],
            "connection" : {
                "username" : "kachnak",
                "password" : "clear-text-ftw"
            },
            "connectionType" : "custom-type://username-and-password",
            "configuration" : {
                "frequency" : "100"
            },
            "configurationType" : 
                "rhq-type://platforms/CPU/resourceConfiguration",
            "operations" : [
                {
                    "id" : "rhq://1234-abcd/PLATFORM/cpu0/overclock",
                    "type" : "rhq-type://platforms/CPU/overclock"
                }
            ]
        }
        
+ Response 201

    [Resource][]

## Data [/data]
The data coming to the number of endpoints under `/data` root are subject 
to changing their IDs before redirecting them to their true destinations 
(i.e. metrics going to rhq-metrics) or dropping them altogether if the 
system determines that the data belongs to a resource that has not been 
inventoried yet.

### Metrics [/data/metrics]
Metrics endpoint. This is identical to RHQ metrics.

### Configurations [/data/configurations]

### Connections [/data/connections]

### Operations [/data/operations]

## Type [/types]
Work with resource and data types.

## Query [/query]
The querying interface.

